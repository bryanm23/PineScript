//@version=5
indicator("Day Trading Signals - Gold & Crypto", shorttitle="DT Signals", overlay=true)

// ============================================================================
// ASSET TYPE SELECTION
// ============================================================================
asset_type = input.string("Gold", "Asset Type", options=["Gold", "Crypto"], 
     tooltip="Select Gold for futures or Crypto for XRP/cryptocurrency")

// ============================================================================
// GOLD-SPECIFIC SETTINGS
// ============================================================================
gold_rsi_length = input.int(14, "Gold RSI Length", minval=1, group="Gold Settings")
gold_rsi_overbought = input.int(70, "Gold RSI Overbought", minval=50, maxval=100, group="Gold Settings")
gold_rsi_oversold = input.int(30, "Gold RSI Oversold", minval=0, maxval=50, group="Gold Settings")
gold_ema_fast = input.int(9, "Gold Fast EMA", minval=1, group="Gold Settings")
gold_ema_slow = input.int(21, "Gold Slow EMA", minval=1, group="Gold Settings")
gold_macd_fast = input.int(12, "Gold MACD Fast", minval=1, group="Gold Settings")
gold_macd_slow = input.int(26, "Gold MACD Slow", minval=1, group="Gold Settings")
gold_macd_signal = input.int(9, "Gold MACD Signal", minval=1, group="Gold Settings")
gold_volume_threshold = input.float(1.2, "Gold Volume Multiplier", minval=1.0, step=0.1, group="Gold Settings")

// ============================================================================
// CRYPTO-SPECIFIC SETTINGS (Optimized for XRP)
// ============================================================================
crypto_rsi_length = input.int(14, "Crypto RSI Length", minval=1, group="Crypto Settings")
crypto_rsi_overbought = input.int(75, "Crypto RSI Overbought", minval=50, maxval=100, group="Crypto Settings")
crypto_rsi_oversold = input.int(25, "Crypto RSI Oversold", minval=0, maxval=50, group="Crypto Settings")
crypto_ema_fast = input.int(8, "Crypto Fast EMA", minval=1, group="Crypto Settings")
crypto_ema_slow = input.int(20, "Crypto Slow EMA", minval=1, group="Crypto Settings")
crypto_macd_fast = input.int(10, "Crypto MACD Fast", minval=1, group="Crypto Settings")
crypto_macd_slow = input.int(24, "Crypto MACD Slow", minval=1, group="Crypto Settings")
crypto_macd_signal = input.int(7, "Crypto MACD Signal", minval=1, group="Crypto Settings")
crypto_volume_threshold = input.float(1.5, "Crypto Volume Multiplier", minval=1.0, step=0.1, group="Crypto Settings")

// ============================================================================
// DYNAMIC PARAMETER SELECTION
// ============================================================================
rsi_length = asset_type == "Gold" ? gold_rsi_length : crypto_rsi_length
rsi_overbought = asset_type == "Gold" ? gold_rsi_overbought : crypto_rsi_overbought
rsi_oversold = asset_type == "Gold" ? gold_rsi_oversold : crypto_rsi_oversold
ema_fast_period = asset_type == "Gold" ? gold_ema_fast : crypto_ema_fast
ema_slow_period = asset_type == "Gold" ? gold_ema_slow : crypto_ema_slow
macd_fast_period = asset_type == "Gold" ? gold_macd_fast : crypto_macd_fast
macd_slow_period = asset_type == "Gold" ? gold_macd_slow : crypto_macd_slow
macd_signal_period = asset_type == "Gold" ? gold_macd_signal : crypto_macd_signal
volume_threshold = asset_type == "Gold" ? gold_volume_threshold : crypto_volume_threshold

// ============================================================================
// INDICATOR CALCULATIONS
// ============================================================================

// RSI Calculation (Relative Strength Index)
rsi = ta.rsi(close, rsi_length)

// EMA Calculation (Exponential Moving Averages)
ema_fast = ta.ema(close, ema_fast_period)
ema_slow = ta.ema(close, ema_slow_period)

// MACD Calculation
[macd_line, signal_line, hist_line] = ta.macd(close, macd_fast_period, macd_slow_period, macd_signal_period)

// Volume Analysis
volume_ma = ta.sma(volume, 20)
volume_spike = volume > (volume_ma * volume_threshold)

// Support and Resistance Levels (using pivot points)
pivot_high = ta.pivothigh(high, 5, 5)
pivot_low = ta.pivotlow(low, 5, 5)
var float resistance = na
var float support = na

if not na(pivot_high)
    resistance := pivot_high
if not na(pivot_low)
    support := pivot_low

// ATR for volatility measurement
atr_length = input.int(14, "ATR Length", minval=1)
atr = ta.atr(atr_length)
atr_percent = (atr / close) * 100

// ============================================================================
// MULTIPLE TIMEFRAME CONFIRMATION
// ============================================================================
enable_mtf = input.bool(false, "Enable Multiple Timeframe Filter", tooltip="Disable for more signals", group="Multiple Timeframe")
mtf_timeframe = input.timeframe("60", "Higher Timeframe", group="Multiple Timeframe", 
     tooltip="Higher timeframe to check trend (e.g., '60' for 1H, '240' for 4H, 'D' for daily)")

// Get higher timeframe data
htf_close = request.security(syminfo.tickerid, mtf_timeframe, close, lookahead=barmerge.lookahead_off)
htf_ema_fast = request.security(syminfo.tickerid, mtf_timeframe, ta.ema(close, ema_fast_period), lookahead=barmerge.lookahead_off)
htf_ema_slow = request.security(syminfo.tickerid, mtf_timeframe, ta.ema(close, ema_slow_period), lookahead=barmerge.lookahead_off)

// Higher timeframe trend
htf_ema_slope = htf_ema_fast - htf_ema_fast[5]
htf_price_above = htf_close > htf_ema_fast and htf_close > htf_ema_slow
htf_price_below = htf_close < htf_ema_fast and htf_close < htf_ema_slow

htf_is_uptrend = htf_ema_fast > htf_ema_slow and htf_ema_slope > 0 and htf_price_above
htf_is_downtrend = htf_ema_fast < htf_ema_slow and htf_ema_slope < 0 and htf_price_below
htf_is_range = not htf_is_uptrend and not htf_is_downtrend

// ============================================================================
// SIGNAL FREQUENCY CONTROL (Must be declared early)
// ============================================================================
signal_frequency = input.string("Normal", "Signal Frequency", options=["Very High", "High", "Normal", "Low"], 
     tooltip="Higher frequency = more signals but potentially lower quality", group="Signal Filtering")
signal_cooldown = input.int(10, "Signal Cooldown (bars)", minval=1, maxval=50, tooltip="Minimum bars between signals", group="Signal Filtering")

// ============================================================================
// MARKET STRUCTURE ANALYSIS (Grimes' Concepts)
// ============================================================================
// Trend Detection using EMA slope and price position
ema_slope_fast = ema_fast - ema_fast[5]
ema_slope_slow = ema_slow - ema_slow[5]
price_above_ema = close > ema_fast and close > ema_slow
price_below_ema = close < ema_fast and close < ema_slow

// Market Structure: Uptrend, Downtrend, or Range
is_uptrend = ema_fast > ema_slow and ema_slope_fast > 0 and price_above_ema
is_downtrend = ema_fast < ema_slow and ema_slope_fast < 0 and price_below_ema
is_range = not is_uptrend and not is_downtrend

// Higher Highs and Higher Lows (Uptrend confirmation)
hh = high > ta.highest(high[1], 10)
ll = low > ta.lowest(low[1], 10)
higher_highs_lows = hh or ll

// Lower Highs and Lower Lows (Downtrend confirmation)
lh = high < ta.highest(high[1], 10)
hl = low < ta.lowest(low[1], 10)
lower_highs_lows = lh or hl

// ============================================================================
// RISK MANAGEMENT (Stop Loss & Take Profit Calculations)
// ============================================================================
risk_reward_ratio = input.float(2.0, "Risk/Reward Ratio", minval=1.0, step=0.5, group="Risk Management")
stop_loss_atr_mult = input.float(1.5, "Stop Loss (ATR Multiplier)", minval=0.5, step=0.5, group="Risk Management")
take_profit_atr_mult = stop_loss_atr_mult * risk_reward_ratio

// Calculate stop loss and take profit levels
var float entry_price = na
var float stop_loss_level = na
var float take_profit_level = na

// ============================================================================
// ENHANCED VOLUME ANALYSIS
// ============================================================================
// Volume trend (increasing/decreasing)
volume_trend_up = volume > volume[1] and volume[1] > volume[2]
volume_trend_down = volume < volume[1] and volume[1] < volume[2]

// Volume-Weighted Average Price (VWAP) for intraday trading
vwap = ta.vwap(hlc3)

// Price relative to VWAP (useful for day trading)
price_above_vwap = close > vwap
price_below_vwap = close < vwap

// ============================================================================
// PRICE ACTION PATTERNS
// ============================================================================
// Engulfing patterns
bullish_engulfing = close > open and close[1] < open[1] and close > open[1] and open < close[1] and close > close[1]

bearish_engulfing = close < open and close[1] > open[1] and close < open[1] and open > close[1] and close < close[1]

// Pin bars (rejection candles)
bullish_pin = (low < low[1] and close > (high + low) / 2) or 
              (math.min(open, close) - low) > (high - math.max(open, close)) * 2

bearish_pin = (high > high[1] and close < (high + low) / 2) or 
              (high - math.max(open, close)) > (math.min(open, close) - low) * 2

// ============================================================================
// SIGNAL GENERATION LOGIC (Simplified & Logical)
// ============================================================================

// Track last signal bar for cooldown
var int last_buy_bar = 0
var int last_short_bar = 0
var int last_sell_bar = 0

bars_since_buy = bar_index - last_buy_bar
bars_since_short = bar_index - last_short_bar
bars_since_sell = bar_index - last_sell_bar

// Simple, logical conditions
ema_bullish_cross = ta.crossover(ema_fast, ema_slow)
ema_bearish_cross = ta.crossunder(ema_fast, ema_slow)
macd_bullish_cross = ta.crossover(macd_line, signal_line)
macd_bearish_cross = ta.crossunder(macd_line, signal_line)

// RSI conditions - more logical
rsi_oversold_now = rsi < rsi_oversold
rsi_was_oversold = rsi[1] < rsi_oversold or rsi[2] < rsi_oversold
rsi_recovering = rsi > rsi[1] and rsi[1] > rsi[2]  // RSI rising

rsi_overbought_now = rsi > rsi_overbought
rsi_was_overbought = rsi[1] > rsi_overbought or rsi[2] > rsi_overbought
rsi_declining = rsi < rsi[1] and rsi[1] < rsi[2]  // RSI falling

// LONG SIGNAL: Uptrend + RSI recovering from oversold + MACD bullish + Volume
// Logic: Buy when price is trending up, RSI was oversold and recovering, momentum confirms
buy_signal_very_high = ema_fast > ema_slow and rsi_was_oversold and rsi_recovering and macd_line > signal_line
buy_signal_high = ema_bullish_cross and rsi_was_oversold and rsi_recovering and macd_bullish_cross and volume_spike
buy_signal_normal = ema_bullish_cross and rsi_was_oversold and rsi_recovering and macd_bullish_cross and volume_spike and is_uptrend
buy_signal_low = ema_bullish_cross and rsi_was_oversold and rsi_recovering and macd_bullish_cross and volume_spike and is_uptrend and near_support

// Select based on frequency setting
buy_signal_base_raw = signal_frequency == "Very High" ? buy_signal_very_high : signal_frequency == "High" ? buy_signal_high : signal_frequency == "Normal" ? buy_signal_normal : buy_signal_low

// Apply MTF filter
buy_signal_base = enable_mtf ? (buy_signal_base_raw and (htf_is_uptrend or htf_is_range)) : buy_signal_base_raw

// SHORT SIGNAL: Downtrend + RSI declining from overbought + MACD bearish + Volume
// Logic: Short when price is trending down, RSI was overbought and declining, momentum confirms
short_signal_very_high = ema_fast < ema_slow and rsi_was_overbought and rsi_declining and macd_line < signal_line
short_signal_high = ema_bearish_cross and rsi_was_overbought and rsi_declining and macd_bearish_cross and volume_spike
short_signal_normal = ema_bearish_cross and rsi_was_overbought and rsi_declining and macd_bearish_cross and volume_spike and is_downtrend
short_signal_low = ema_bearish_cross and rsi_was_overbought and rsi_declining and macd_bearish_cross and volume_spike and is_downtrend and near_resistance

// Select based on frequency setting
short_signal_base_raw = signal_frequency == "Very High" ? short_signal_very_high : signal_frequency == "High" ? short_signal_high : signal_frequency == "Normal" ? short_signal_normal : short_signal_low

// Apply MTF filter
short_signal_base = enable_mtf ? (short_signal_base_raw and (htf_is_downtrend or htf_is_range)) : short_signal_base_raw

// EXIT SIGNAL: Exit long when trend reverses or RSI overbought
// Logic: Exit when momentum reverses or profit target reached
sell_signal_very_high = ema_bearish_cross and rsi_overbought_now
sell_signal_high = ema_bearish_cross and (rsi_overbought_now or macd_bearish_cross)
sell_signal_normal = ema_bearish_cross and (rsi_overbought_now or macd_bearish_cross) and is_downtrend
sell_signal_low = ema_bearish_cross and rsi_overbought_now and macd_bearish_cross and is_downtrend

// Select based on frequency setting
sell_signal_base = signal_frequency == "Very High" ? sell_signal_very_high : signal_frequency == "High" ? sell_signal_high : signal_frequency == "Normal" ? sell_signal_normal : sell_signal_low

// ============================================================================
// MOVE PREDICTION & FILTERING (Only signal if move is worth taking)
// ============================================================================
test_mode = input.bool(false, "Test Mode (Relaxed Conditions)", tooltip="Enable to see more signals for testing", group="Signal Filtering")
enable_move_filtering = input.bool(false, "Enable Move Filtering", tooltip="Filter signals by predicted move size", group="Signal Filtering")
min_move_percent = input.float(0.3, "Minimum Move % to Signal", minval=0.1, maxval=5.0, step=0.1, group="Signal Filtering")
show_move_predictions = input.bool(true, "Show Move Predictions in Table", group="Signal Filtering")

// Calculate potential move targets
// For LONG: distance to resistance or ATR-based target
potential_long_move = 0.0
if not na(resistance) and resistance > close
    potential_long_move := ((resistance - close) / close) * 100
else
    // Use ATR-based target if no resistance (always available)
    potential_long_move := (atr * 2 / close) * 100

// For SHORT: distance to support or ATR-based target  
potential_short_move = 0.0
if not na(support) and support < close
    potential_short_move := ((close - support) / close) * 100
else
    // Use ATR-based target if no support (always available)
    potential_short_move := (atr * 2 / close) * 100

// For EXIT: use ATR-based exit (always available)
potential_exit_move = (atr * 1.5 / close) * 100

// Test mode: simplified conditions for testing
buy_signal_test = ema_fast > ema_slow and rsi_was_oversold and macd_line > signal_line
short_signal_test = ema_fast < ema_slow and rsi_was_overbought and macd_line < signal_line
sell_signal_test = ema_bearish_cross and rsi_overbought_now

// Filter signals based on predicted move size
// Make sure we always have a value (ATR fallback ensures this)
buy_signal_raw = (test_mode ? buy_signal_test : buy_signal_base) and (not enable_move_filtering or potential_long_move >= min_move_percent)
short_signal_raw = (test_mode ? short_signal_test : short_signal_base) and (not enable_move_filtering or potential_short_move >= min_move_percent)
sell_signal_raw = (test_mode ? sell_signal_test : sell_signal_base) and (not enable_move_filtering or potential_exit_move >= min_move_percent)

// Apply cooldown and prevent contradictory signals
buy_signal_final = buy_signal_raw and not short_signal_raw and bars_since_buy >= signal_cooldown and bars_since_short >= signal_cooldown
short_signal_final = short_signal_raw and not buy_signal_raw and bars_since_short >= signal_cooldown and bars_since_buy >= signal_cooldown
sell_signal_final = sell_signal_raw and bars_since_sell >= signal_cooldown

// Update last signal bars
if buy_signal_final
    last_buy_bar := bar_index
if short_signal_final
    last_short_bar := bar_index
if sell_signal_final
    last_sell_bar := bar_index

buy_signal = buy_signal_final
short_signal = short_signal_final
sell_signal = sell_signal_final

// ============================================================================
// VISUALIZATION
// ============================================================================

// Plot EMAs
plot(ema_fast, "Fast EMA", color=color.blue, linewidth=2)
plot(ema_slow, "Slow EMA", color=color.orange, linewidth=2)

// Plot VWAP (important for day trading)
plot(vwap, "VWAP", color=color.purple, linewidth=1, style=plot.style_line)

// Plot Support/Resistance
plot(support, "Support", color=color.green, style=plot.style_linebr, linewidth=1)
plot(resistance, "Resistance", color=color.red, style=plot.style_linebr, linewidth=1)

// Market Structure Background
bgcolor(is_uptrend ? color.new(color.green, 95) : is_downtrend ? color.new(color.red, 95) : na, title="Market Structure")

// Buy Signals with Labels
plotshape(buy_signal, style=shape.triangleup, location=location.belowbar, 
          color=color.lime, size=size.large, title="LONG")
if buy_signal
    label.new(bar_index, low * 0.998, "LONG", style=label.style_label_up, color=color.lime, textcolor=color.white, size=size.normal)

// Sell Signals with Labels
plotshape(sell_signal, style=shape.triangledown, location=location.abovebar, 
          color=color.red, size=size.large, title="EXIT")
if sell_signal
    label.new(bar_index, high * 1.002, "EXIT", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.normal)

// Short Signals with Labels
plotshape(short_signal, style=shape.xcross, location=location.abovebar, 
          color=color.fuchsia, size=size.large, title="SHORT")
if short_signal
    label.new(bar_index, high * 1.002, "SHORT", style=label.style_label_down, color=color.fuchsia, textcolor=color.white, size=size.normal)

// ============================================================================
// ALERTS
// ============================================================================
alertcondition(buy_signal, title="Buy Signal", message="BUY signal triggered for {{ticker}}")
alertcondition(sell_signal, title="Sell Signal", message="SELL signal triggered for {{ticker}}")
alertcondition(short_signal, title="Short Signal", message="SHORT signal triggered for {{ticker}}")

// ============================================================================
// TABLE DISPLAY (Optional - shows current indicator values)
// ============================================================================
show_table = input.bool(true, "Show Info Table", group="Display Options")

if show_table and barstate.islast
    rows = show_move_predictions ? 13 : 10
    if enable_mtf
        rows := rows + 1
    var table info_table = table.new(position.top_right, 2, rows, bgcolor=color.new(color.black, 80), border_width=1)
    table.cell(info_table, 0, 0, "Asset", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 0, asset_type, text_color=color.white)
    table.cell(info_table, 0, 1, "Market", text_color=color.white, bgcolor=color.new(color.gray, 50))
    market_structure_text = is_uptrend ? "Uptrend" : is_downtrend ? "Downtrend" : "Range"
    market_structure_color = is_uptrend ? color.lime : is_downtrend ? color.red : color.yellow
    table.cell(info_table, 1, 1, market_structure_text, text_color=market_structure_color)
    
    // Higher Timeframe Trend
    row_offset = 0
    if enable_mtf
        table.cell(info_table, 0, 2, "HTF Trend", text_color=color.white, bgcolor=color.new(color.gray, 50))
        htf_trend_text = htf_is_uptrend ? "Uptrend" : htf_is_downtrend ? "Downtrend" : "Range"
        htf_trend_color = htf_is_uptrend ? color.lime : htf_is_downtrend ? color.red : color.yellow
        table.cell(info_table, 1, 2, htf_trend_text + " (" + mtf_timeframe + ")", text_color=htf_trend_color)
        row_offset := 1
    table.cell(info_table, 0, 2 + row_offset, "RSI", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 2 + row_offset, str.tostring(math.round(rsi, 2)), 
               text_color=rsi > rsi_overbought ? color.red : rsi < rsi_oversold ? color.lime : color.white)
    table.cell(info_table, 0, 3 + row_offset, "EMA Cross", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 3 + row_offset, ema_fast > ema_slow ? "Bullish" : "Bearish", 
               text_color=ema_fast > ema_slow ? color.lime : color.red)
    table.cell(info_table, 0, 4 + row_offset, "MACD", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 4 + row_offset, macd_line > signal_line ? "Bullish" : "Bearish", 
               text_color=macd_line > signal_line ? color.lime : color.red)
    table.cell(info_table, 0, 5 + row_offset, "Volume", text_color=color.white, bgcolor=color.new(color.gray, 50))
    volume_status = volume_spike ? "High" : volume_trend_up ? "Rising" : "Normal"
    table.cell(info_table, 1, 5 + row_offset, volume_status, 
               text_color=volume_spike ? color.yellow : volume_trend_up ? color.orange : color.white)
    table.cell(info_table, 0, 6 + row_offset, "VWAP", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 6 + row_offset, price_above_vwap ? "Above" : "Below", 
               text_color=price_above_vwap ? color.lime : color.red)
    table.cell(info_table, 0, 7 + row_offset, "ATR %", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 7 + row_offset, str.tostring(math.round(atr_percent, 2)) + "%", text_color=color.white)
    table.cell(info_table, 0, 8 + row_offset, "R:R Ratio", text_color=color.white, bgcolor=color.new(color.gray, 50))
    table.cell(info_table, 1, 8 + row_offset, str.tostring(risk_reward_ratio) + ":1", text_color=color.white)
    
    if show_move_predictions
        table.cell(info_table, 0, 9 + row_offset, "Min Move", text_color=color.white, bgcolor=color.new(color.gray, 50))
        table.cell(info_table, 1, 9 + row_offset, str.tostring(min_move_percent) + "%", text_color=color.yellow)
        table.cell(info_table, 0, 10 + row_offset, "Long Move", text_color=color.white, bgcolor=color.new(color.gray, 50))
        table.cell(info_table, 1, 10 + row_offset, str.tostring(math.round(potential_long_move, 2)) + "%", 
                   text_color=potential_long_move >= min_move_percent ? color.lime : color.gray)
        table.cell(info_table, 0, 11 + row_offset, "Short Move", text_color=color.white, bgcolor=color.new(color.gray, 50))
        table.cell(info_table, 1, 11 + row_offset, str.tostring(math.round(potential_short_move, 2)) + "%", 
                   text_color=potential_short_move >= min_move_percent ? color.lime : color.gray)

